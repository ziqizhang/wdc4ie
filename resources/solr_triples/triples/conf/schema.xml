<?xml version="1.0" ?>

<!--  
 This is the Solr schema file for TATA-STEEL Terminology Recognition content indexing engine.
 -->
<schema name="triples" version="2.0">
   <!-- Valid attributes for fields:
     name: mandatory - the name for the field
     type: mandatory - the name of a field type from the 
       <types> fieldType section
     indexed: true if this field should be indexed (searchable or sortable)
     stored: true if this field should be retrievable
     docValues: true if this field should have doc values. Doc values are
       useful for faceting, grouping, sorting and function queries. Although not
       required, doc values will make the index faster to load, more
       NRT-friendly and more memory-efficient. They however come with some
       limitations: they are currently only supported by StrField, UUIDField
       and all Trie*Fields, and depending on the field type, they might
       require the field to be single-valued, be required or have a default
       value (check the documentation of the field type you're interested in
       for more information)
     multiValued: true if this field may contain multiple values per document
     omitNorms: (expert) set to true to omit the norms associated with
       this field (this disables length normalization and index-time
       boosting for the field, and saves some memory).  Only full-text
       fields or fields that need an index-time boost need norms.
       Norms are omitted for primitive (non-analyzed) types by default.
     termVectors: [false] set to true to store the term vector for a
       given field.
       When using MoreLikeThis, fields used for similarity should be
       stored for best performance.
     termPositions: Store position information with the term vector.  
       This will increase storage costs.
     termOffsets: Store offset information with the term vector. This 
       will increase storage costs.
     termPayloads: Store payload information with the term vector. This
       will increase storage costs.
     required: The field is required.  It will throw an error if the
       value does not exist
     default: a value that should be used if no value is specified
       when adding a document.
   -->
	<types>
		<fieldtype name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true" />
		
		<fieldType name="int" class="solr.TrieIntField" precisionStep="0" positionIncrementGap="0"/>
		<fieldType name="float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
		<fieldType name="long" class="solr.TrieLongField" precisionStep="0" positionIncrementGap="0"/>
		<fieldType name="double" class="solr.TrieDoubleField" precisionStep="0" positionIncrementGap="0"/>
		<!-- boolean type: "true" or "false" -->
		<fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>
	
		<!-- This will stop your Solr from crashing when Tika index fields that Solr don't know of. -->
		<fieldtype name="binary" class="solr.BinaryField"/>
		
		<!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
			 is a more restricted form of the canonical representation of dateTime
			 http://www.w3.org/TR/xmlschema-2/#dateTime    
			 The trailing "Z" designates UTC time and is mandatory.
			 Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
			 All other components are mandatory.

			 Expressions can also be used to denote calculations that should be
			 performed relative to "NOW" to determine the value, ie...

				   NOW/HOUR
					  ... Round to the start of the current hour
				   NOW-1DAY
					  ... Exactly 1 day prior to now
				   NOW/DAY+6MONTHS+3DAYS
					  ... 6 months and 3 days in the future from the start of
						  the current day
						  
			 Consult the TrieDateField javadocs for more information.

			 Note: For faster range queries, consider the tdate type
		-->
		<fieldType name="date" class="solr.TrieDateField" precisionStep="0" positionIncrementGap="0"/>
		<!--<fieldType name="pdate" class="solr.DateField" sortMissingLast="true" />-->
		<fieldType name="pdate" class="solr.TrieDateField" precisionStep="6" positionIncrementGap="0"/>		
		
		
	    <field name="payloads" type="payloads" indexed="true" stored="true"/>
			
		<fieldType name="payloads" stored="false" indexed="true" class="solr.TextField" >
			<analyzer>
				<tokenizer class="solr.WhitespaceTokenizerFactory"/>
				<!--
				The DelimitedPayloadTokenFilter can put payloads on tokens... for example,
				a token of "foo|1.4"  would be indexed as "foo" with a payload of 1.4f
				Attributes of the DelimitedPayloadTokenFilterFactory : 
				 "delimiter" - a one character delimiter. Default is | (pipe)
			 "encoder" - how to encode the following value into a playload
				float -> org.apache.lucene.analysis.payloads.FloatEncoder,
				integer -> o.a.l.a.p.IntegerEncoder
				identity -> o.a.l.a.p.IdentityEncoder
					Fully Qualified class name implementing PayloadEncoder, Encoder must have a no arg constructor.
				 -->
				<filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
			</analyzer>
		</fieldType>
		
		<!--
		 Numeric field types that index each value at various levels of precision
		 to accelerate range queries when the number of values between the range
		 endpoints is large. See the javadoc for NumericRangeQuery for internal
		 implementation details.

		 Smaller precisionStep values (specified in bits) will lead to more tokens
		 indexed per value, slightly larger index size, and faster range queries.
		 A precisionStep of 0 disables indexing at different precision levels.
		-->
		<fieldType name="tint" class="solr.TrieIntField" precisionStep="8" positionIncrementGap="0"/>
		<fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
		<fieldType name="tlong" class="solr.TrieLongField" precisionStep="8" positionIncrementGap="0"/>
		<fieldType name="tdouble" class="solr.TrieDoubleField" precisionStep="8" positionIncrementGap="0"/>
		
		<!-- The "RandomSortField" is not used to store or search any
			 data.  You can declare fields of this type it in your schema
			 to generate pseudo-random orderings of your docs for sorting 
			 or function purposes.  The ordering is generated based on the field
			 name and the version of the index. As long as the index version
			 remains unchanged, and the same field name is reused,
			 the ordering of the docs will be consistent.  
			 If you want different psuedo-random orderings of documents,
			 for the same version of the index, use a dynamicField and
			 change the field name in the request.
		 -->
		<fieldType name="random" class="solr.RandomSortField" indexed="true" />	
		<fieldType name="tdate" class="solr.TrieDateField" precisionStep="6" positionIncrementGap="0"/>
		<fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
			<analyzer type="index">
				<tokenizer class="solr.StandardTokenizerFactory" />
				<filter class="solr.ASCIIFoldingFilterFactory"/>
				<!--filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/-->
				<!-- in this example, we will only use synonyms at query time <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/> -->
				<filter class="solr.LowerCaseFilterFactory" />				
			</analyzer>
			<analyzer type="query">
				<tokenizer class="solr.StandardTokenizerFactory" />
				<filter class="solr.ASCIIFoldingFilterFactory"/>
				<!--filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/-->
				<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true" />
				<filter class="solr.LowerCaseFilterFactory" />
			</analyzer>
		</fieldType>			
	</types>
	

	<fields>
	    <!-- field names should consist of alphanumeric or underscore characters only and
		  not start with a digit.  This is not currently strictly enforced,
		  but other field names will not have first class support from all components
		  and back compatibility is not guaranteed.  Names with both leading and
		  trailing underscores (e.g. _version_) are reserved.
	    -->
	<field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
        <!--ID will be in the format of [filename|line_number] -->
	<field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false" />
	<!--tld is the top level domain, e.g., uk, ru, com, org, of the source webpage -->
	<field name="tld" type="string" indexed="true" stored="true" multiValued="false"/>
	<!--host of the source webpage -->
	<field name="host" type="string" indexed="true" stored="true" multiValued="false"/>
  	<!--subject of the triple as a string -->
	<!--field name="subject" type="string" indexed="true" stored="true" multiValued="false"/-->	
	<!--subject namespace if any-->
	<!--field name="subject_namespace" type="string" indexed="true" stored="false" multiValued="false"/-->
	<!--predicate of the triple as a string -->
	<field name="predicate" type="string" indexed="true" stored="true" multiValued="false"/>
	<!--predicate namespace -->
	<field name="predicate_namespace" type="string" indexed="true" stored="false" multiValued="false"/>	
	<!--object of the triple as a string -->
	<field name="object" type="string" indexed="true" stored="true" multiValued="false"/>
	<!--object namespace, if the object is a URI -->
	<field name="object_namespace" type="string" indexed="true" stored="false" multiValued="false"/>	
	<!--object of the triple as tokenised text. The object is firstly split by '/' if it is a URI-->
	<!--field name="object_text" type="text_general" indexed="true" stored="false" multiValued="false"/-->
	<!--object type contains strings indicating the data type, this can be uri, literal and in case of literal, other
          values indicating the language '@en' and datatype will be also stored, if available -->
	<field name="object_type" type="string" indexed="true" stored="true" multiValued="true"/>
	<!--provenance of this triple, as the format of the source wdc nquad file-->
	<field name="provenance_wdc_format" type="string" indexed="false" stored="true" multiValued="false"/>
	<!--provenance of this triple, as the source wdc nquad file-->
	<field name="provenance_wdc_nquad_file" type="string" indexed="false" stored="true" multiValued="false"/>
	<!--provenance of this triple, as the source wdc nquad file-->
	<field name="provenance_wdc_nquad_line" type="string" indexed="false" stored="true" multiValued="false"/>
	<!--provenance of this triple, as the source CC warc file-->
	<field name="provenance_cc_warc" type="string" indexed="false" stored="true" multiValued="false"/>
	<!--provenance of this triple, as the start and end offsets in the source CC warc file. This is in the format of 'start,end'-->
	<field name="provenance_cc_warc_offsets" type="string" indexed="false" stored="true" multiValued="false"/>
	<!--provenance of this triple, as the original URL. This can become obsolete or changed over time-->
	<field name="provenance_url" type="string" indexed="false" stored="true" multiValued="false"/>
	<field name="text" type="string" indexed="false" stored="false" multiValued="false"/>


       	<dynamicField name="*_i"  type="int"    indexed="true"  stored="true"/>
	   <dynamicField name="*_is" type="int"    indexed="true"  stored="true"  multiValued="true"/>
	   <dynamicField name="*_s"  type="string"  indexed="true"  stored="true" />
	   <dynamicField name="*_ss" type="string"  indexed="true"  stored="true" multiValued="true"/>
	   <dynamicField name="*_l"  type="long"   indexed="true"  stored="true"/>
	   <dynamicField name="*_ls" type="long"   indexed="true"  stored="true"  multiValued="true"/>
	   <dynamicField name="*_b"  type="boolean" indexed="true" stored="true"/>
	   <dynamicField name="*_bs" type="boolean" indexed="true" stored="true"  multiValued="true"/>
	   <dynamicField name="*_f"  type="float"  indexed="true"  stored="true"/>
	   <dynamicField name="*_fs" type="float"  indexed="true"  stored="true"  multiValued="true"/>
	   <dynamicField name="*_d"  type="double" indexed="true"  stored="true"/>
	   <dynamicField name="*_ds" type="double" indexed="true"  stored="true"  multiValued="true"/>
       <dynamicField name="random_*" type="random" />
   	
	<copyField source="id" dest="text"/>
	   <!-- copyField commands copy one field to another at the time a document
        is added to the index.  It's used either to index the same field differently,
        or to add multiple fields to the same field for easier/faster searching.  -->	     
	</fields>

	<uniqueKey>id</uniqueKey>

	<!--defaultSearchField>id</defaultSearchField-->

	<!--solrQueryParser defaultOperator="OR" /-->
</schema>
